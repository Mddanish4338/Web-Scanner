"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("./browser");
function arrayify(src) {
    if (!Array.isArray(src)) {
        return [src];
    }
    return src;
}
function injectAxeModule(frame) {
    return frame.addScriptTag({
        path: require.resolve('axe-core')
    });
}
function injectAxeString(frame, source) {
    return frame.evaluate(source);
}
function injectAxeChild(frame, source) {
    const injections = frame
        .childFrames()
        .map(subFrame => injectAxeChild(subFrame, source))
        .reduce((acc, arr) => acc.concat(arr), []);
    const reportError = () => {
        console.error(`Failed to inject axe-core into frame (${frame.url()})`);
    };
    let injectP;
    if (!source) {
        injectP = injectAxeModule(frame);
    }
    else {
        injectP = injectAxeString(frame, source);
    }
    injections.push(injectP.catch(reportError));
    return injections;
}
function injectAxe(frame, source) {
    const injections = frame
        .childFrames()
        .map(subFrame => injectAxeChild(subFrame, source))
        .reduce((acc, arr) => acc.concat(arr), []);
    let injectP;
    if (!source) {
        injectP = injectAxeModule(frame);
    }
    else {
        injectP = injectAxeString(frame, source);
    }
    injections.push(injectP);
    return Promise.all(injections).then(() => undefined);
}
function isPage(pageFrame) {
    return pageFrame.mainFrame !== undefined;
}
function getFrame(pageFrame) {
    if (isPage(pageFrame)) {
        return pageFrame.mainFrame();
    }
    return pageFrame;
}
function ensureFrameReady(frame) {
    return __awaiter(this, void 0, void 0, function* () {
        yield frame.waitForSelector('html');
        const pageReady = yield frame.evaluate(browser_1.pageIsLoaded);
        if (!pageReady) {
            throw new Error('Page/Frame is not ready');
        }
    });
}
function normalizeContext(includes, excludes) {
    if (!excludes.length && !includes.length) {
        return null;
    }
    const ctx = {};
    if (excludes.length) {
        ctx.exclude = excludes;
    }
    if (includes.length) {
        ctx.include = includes;
    }
    return ctx;
}
class AxePuppeteer {
    constructor(pageFrame, source) {
        this.frame = getFrame(pageFrame);
        this.source = source;
        this.includes = [];
        this.excludes = [];
        this.axeOptions = null;
        this.config = null;
    }
    include(selector) {
        selector = arrayify(selector);
        this.includes.push(selector);
        return this;
    }
    exclude(selector) {
        selector = arrayify(selector);
        this.excludes.push(selector);
        return this;
    }
    options(options) {
        this.axeOptions = options;
        return this;
    }
    withRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'rule',
            values: rules
        };
        return this;
    }
    withTags(tags) {
        tags = arrayify(tags);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        this.axeOptions.runOnly = {
            type: 'tag',
            values: tags
        };
        return this;
    }
    disableRules(rules) {
        rules = arrayify(rules);
        if (!this.axeOptions) {
            this.axeOptions = {};
        }
        const newRules = {};
        for (const rule of rules) {
            newRules[rule] = {
                enabled: false
            };
        }
        this.axeOptions.rules = newRules;
        return this;
    }
    configure(config) {
        if (typeof config !== 'object') {
            throw new Error('AxePuppeteer needs an object to configure. See axe-core configure API.');
        }
        this.config = config;
        return this;
    }
    analyze(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield ensureFrameReady(this.frame);
                yield injectAxe(this.frame, this.source);
                const context = normalizeContext(this.includes, this.excludes);
                const axeResults = yield this.frame.evaluate(browser_1.runAxe, this.config, context, this.axeOptions);
                if (callback) {
                    callback(null, axeResults);
                }
                return axeResults;
            }
            catch (err) {
                if (callback) {
                    callback(err);
                    return null;
                }
                throw err;
            }
        });
    }
}
exports.AxePuppeteer = AxePuppeteer;
//# sourceMappingURL=axePuppeteer.js.map